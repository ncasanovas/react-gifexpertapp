{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","categories","type","value","onChange","target","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","GifGridItem","className","src","alt","GifGrid","loading","state","setstate","useEffect","then","imgs","useFetchGifs","GifExpertApp","ReactDOM","render","document","getElementById"],"mappings":"2MAGaA,EAAc,SAAC,GAAuB,IAArBC,EAAoB,EAApBA,cAAoB,EAGVC,mBAAS,IAHC,mBAGvCC,EAHuC,KAG3BC,EAH2B,KAqB9C,OACI,eAAC,WAAD,WACI,iFACA,sBAAMC,SAdO,SAACC,GAElBA,EAAEC,iBACCJ,EAAWK,OAAOC,OAAS,IAE1BR,GAAe,SAAAS,GAAU,OAAKP,GAAL,mBAAoBO,OAC7CN,EAAc,MAQd,SACI,uBACIO,KAAK,OACLC,MAAQT,EACRU,SAtBU,SAACP,GACvBF,EAAcE,EAAEQ,OAAOF,gB,+BCPlBG,EAAO,uCAAG,WAAMC,GAAN,uBAAAC,EAAA,6DAGbC,EAHa,iDAGoCC,UAAUH,GAH9C,+DAIAI,MAAMF,GAJN,cAIbG,EAJa,gBAMEA,EAAKC,OANP,uBAMZC,EANY,EAMZA,KAEDC,EAAOD,EAAKE,KAAK,SAAAC,GAAQ,IAAD,EAE1B,MAAO,CACHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MAEXV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,iBAAiBZ,QAdvB,kBAiBZM,GAjBY,4CAAH,sDCFPO,EAAc,SAAC,GAAmB,IAAjBH,EAAgB,EAAhBA,MAAOV,EAAS,EAATA,IACjC,OACI,sBAAKc,UAAU,yCAAf,UACI,qBAAKC,IAAKf,EAAKgB,IAAKN,IACpB,4BAAIA,QCDHO,EAAU,SAAC,GAAgB,IAAfnB,EAAc,EAAdA,SAAc,ECEX,SAACA,GAAa,MAGZd,mBAAS,CAC/BqB,KAAM,GACNa,SAAS,IALyB,mBAG/BC,EAH+B,KAGxBC,EAHwB,KA+BtC,OAlBAC,qBAAU,WAENxB,EAAQC,GAEHwB,MAAK,SAAAC,GAIEH,EAAS,CACLf,KAAMkB,EACNL,SAAQ,SAIzB,CAACpB,IAIGqB,ED7BwBK,CAAa1B,GAAhCa,EAJuB,EAI5BN,KAAaa,EAJe,EAIfA,QAgBpB,OACI,eAAC,WAAD,WACI,6BAAKpB,IAEHoB,GAAW,mBAAGJ,UAAU,mCAAb,qBACb,qBAAKA,UAAU,YAAf,SAEQH,EAAOJ,KAAI,SAAAC,GAAG,OAEV,cAAC,EAAD,eAEQA,GADCA,EAAIC,aEiBtBgB,EA7CM,WAAM,MAKazC,mBAAS,CAAC,UALvB,mBAKhBQ,EALgB,KAKJT,EALI,KAqBvB,OACI,eAAC,WAAD,WACI,oEACA,cAAC,EAAD,CAAaA,cAAiBA,IAC9B,uBAEA,6BAEQS,EAAWe,KAAI,SAAAT,GAAQ,OAEnB,cAAC,EAAD,CAEIA,SAAUA,GADLA,YChCjC4B,IAASC,OAEL,cAAC,EAAD,IAEFC,SAASC,eAAe,W","file":"static/js/main.d24c4a05.chunk.js","sourcesContent":["import { Fragment, useState } from \"react\";\r\nimport PropTypes from 'prop-types';\r\n\r\nexport const AddCategory = ( {setCategories} ) => {\r\n\r\n\r\n    const [inputValue, setInputValue] = useState('');\r\n    \r\n    //Actualiza el valor del input\r\n    const handleInputChange = (e) => {\r\n        setInputValue(e.target.value);\r\n    }\r\n\r\n    const handleSubmit = (e) => {\r\n        //para evitar refrescar la pagina\r\n        e.preventDefault();\r\n        if(inputValue.trim().length > 2){\r\n            //Con pasar setCategories ya tengo la referencia a categories\r\n            setCategories( categories => [inputValue, ...categories]);\r\n            setInputValue('');\r\n        }\r\n      \r\n    }\r\n\r\n    return (\r\n        <Fragment>\r\n            <h4>Ingrese la categoría y luego presione enter:</h4>\r\n            <form onSubmit={handleSubmit}>\r\n                <input \r\n                    type=\"text\"\r\n                    value= {inputValue}\r\n                    onChange={ handleInputChange}\r\n                />\r\n            </form>\r\n        </Fragment>\r\n    )\r\n    \r\n}\r\n\r\nAddCategory.propTypes = {\r\n    setCategories: PropTypes.func.isRequired\r\n}","//Los helpers son funciones que hacen un cierto trabajo en específico. No hace falta que redibujen el state.\r\n\r\n//Como es async esta función no regresa los gifs, sino una promesa que resuelve la coleccipon de los gifs.\r\nexport const getGifs = async(category) => {\r\n   \r\n    //encodeURI reemplaza los espacios\r\n    const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI(category)}&limit=10&api_key=dFFCrdfC1fvOK2FRWutxSqeKuFBwrTo6`;\r\n    const resp = await fetch(url);\r\n    //Me interesa la data que viene dentro de esa data entonces hago desestructuración\r\n    const {data} = await resp.json(); \r\n\r\n    const gifs = data.map( img => {\r\n\r\n        return {\r\n            id: img.id,\r\n            title: img.title,\r\n            //Si trae imagenes entonces que me muestre la medium\r\n            url: img.images?.downsized_medium.url            }\r\n    });\r\n\r\n    return gifs;\r\n\r\n}","\r\nexport const GifGridItem = ({ title, url}) => {\r\n    return (\r\n        <div className=\"card animate__animated animate__fadeIn\">\r\n            <img src={url} alt={title} />\r\n            <p>{title}</p>\r\n        </div>\r\n    )\r\n}\r\n","import React, {Fragment} from 'react';\r\nimport { useFetchGifs } from '../hooks/useFetchGifs';\r\nimport { GifGridItem } from './GifGridItem';\r\n\r\nexport const GifGrid = ({category}) => {\r\n\r\n    //const [images, setImages] = useState([]);  \r\n    \r\n    const {data:images, loading} = useFetchGifs(category);\r\n\r\n   \r\n    //El useEffect permite ejecutar cierto codigo de manera condicional. Si uso solo useState,\r\n    //todo el código se vuelve a ejecutar cada vez que hago click en el botón, es decir se vuelve a ejecutar la petición http\r\n    // ya que se da cuenta que el componente cambio, por lo tanto vuelve a llamar a getGifs y eso no es correcto.\r\n    //Es como el componentDidMount. [] es la lista de dependencias. Como le mando category, si esta cambia va a volver a ejecutar useEffect.\r\n    //Se ejecuta la instrucción cuando el componente es renderizado por primera vez.\r\n    \r\n    /*useEffect(() => {\r\n        getGifs(category)\r\n            .then(setImages);\r\n    }, [category])*/\r\n\r\n    \r\n\r\n    return (\r\n        <Fragment>\r\n            <h3>{category}</h3>\r\n            {/* && es forma corta, si es true hace eso, sino no hace nada */}\r\n            { loading && <p className=\"animate__animated animate__flash\">Loading</p> }\r\n            <div className=\"card-grid\">\r\n                \r\n                {   images.map(img => (\r\n                    \r\n                        <GifGridItem \r\n                            key={img.id}\r\n                            {...img}\r\n                            \r\n                        />\r\n                    ))\r\n                }\r\n                \r\n            </div>\r\n        </Fragment>\r\n     \r\n    )\r\n}\r\n","import { useState, useEffect } from 'react';\r\nimport { getGifs } from '../helpers/getGifs';\r\n\r\n//Hooks son funciones. Pueden tener su estado, puede indicar a otros componentes cuando\r\n//deben de renderizarse porque algo cambió.\r\n\r\nexport const useFetchGifs = (category) => {\r\n\r\n    //Cuando se llame a esta función por primera vez va a tener este estado por defecto\r\n    const [state, setstate] = useState({\r\n        data: [],\r\n        loading: true\r\n    });\r\n\r\n    //Aca ahgo la petición http y traigo las imagenes.\r\n    //Evalúa este efecto sólo cuando la categoría cambia\r\n    //Loading en false porque ya terminó de cargar\r\n    \r\n    //Se hace el efecto para que se dispare solo cuando cambia la categoria\r\n    useEffect(() => {\r\n        //Hace la petición http\r\n        getGifs(category)\r\n            //Tenemos las imágenes\r\n            .then(imgs => {\r\n                //Ponemos el timeoiut intencional para hacerlo mas lento\r\n               //setTimeout(() => {\r\n                   //Cuando tenemos la data se llama al setState. Éste cambia la información. Va a disparar una renderización en el componente GifGrid.\r\n                    setstate({\r\n                        data: imgs,\r\n                        loading:false\r\n                });\r\n               //}, 1500);\r\n            })\r\n    }, [category]);\r\n\r\n    \r\n\r\n    return state; // { data: [], loading: true}\r\n}","import { Fragment, useState } from \"react\";\r\nimport { AddCategory } from \"./components/AddCategory\";\r\nimport { GifGrid } from \"./components/GifGrid\";\r\n\r\n\r\n//No se debe colocar key=i. key es el id único del elemento, no puede ser el indice.\r\nconst GifExpertApp = () => {\r\n  \r\n\r\n    //const categories = ['One Punch', 'Dragon Ball'];\r\n\r\n    const [categories, setCategories] = useState(['Hello']);\r\n\r\n    /*const handleAdd = (e) => {\r\n\r\n        setCategories(['Twin Peaks', ...categories, ]);\r\n\r\n        //NO funciona con el push,\r\n        //otra forma es:\r\n        //el callback categories es el estado anterior. Devuelve el nuevo estado que es un nuevo arreglo con los valores anteriores mas el que agrego.\r\n        //setCategories(categories => [...categories, 'Twin Peaks']);\r\n    }*/\r\n\r\n\r\n\r\n   \r\n\r\n    return (\r\n        <Fragment>\r\n            <h1>GifExpertApp - Búsqueda de Gifs</h1>\r\n            <AddCategory setCategories = {setCategories}/>\r\n            <hr />\r\n\r\n            <ol>\r\n                { \r\n                    categories.map(category => (\r\n                   \r\n                        <GifGrid \r\n                            key={category}\r\n                            category={category} \r\n                        />\r\n                \r\n                    ))\r\n                }   \r\n            </ol>     \r\n        </Fragment>\r\n    )\r\n}\r\n\r\n\r\n\r\nexport default GifExpertApp;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport GifExpertApp from './GifExpertApp';\n\n\nReactDOM.render(\n\n    <GifExpertApp />,\n\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}